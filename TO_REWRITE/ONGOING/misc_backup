    # def generate_ring_strip_on_sky_plane(self, ring_center, ring_width,
                                         # disk_pos, disk_inc):
        # """Transform disk ring from disk polar coodinate to sky cartesian coordinate

        # Args:
          # ring_center(float): radius of center of ring strip
          # ring_width(float): width of ring strip
          # disk_pos(float): position angle of disk (unit: degree)
          # disk_inc(float): inclination angle of disk (unit: degree)

        # Returns:
            # 2D float array: strip inner boundary x,y position on sky plane
            # 2D float array: strip outer boundary x,y position on sky plane

        # """
        # # Find
        # ring_inner_bound = ring_center - ring_width / 2.
        # ring_outer_bound = ring_center + ring_width / 2.

        # self.transform_disk_polar_to_sky_plane_cartesian()
        # gap_inner = self.transform_disk_polar_to_sky_plane_cartesian(
            # xdim, ydim, r_inner, pos, inc, r_unit=r_unit)
        # gap_outer = self.transform_disk_polar_to_sky_plane_cartesian(
            # xdim, ydim, r_outer, pos, inc, r_unit=r_unit)







        # return gap_inner, gap_outer

    # def generate_ring_strip_on_sky_plane_test(self):

        # max_width = 50.
        # test_disk_inc = 47.5
        # test_disk_pos = 120.
        # test_central_radius = 30.
        # test_width = 5.

        # # Axis for both disk coord and sky coord
        # disk_axis = np.array([[max_width, -max_width, 0., 0.],
                              # [0., 0., max_width, -max_width]])
        # sky_axis = np.array(
            # self.transform_to_sky_coord(disk_axis[0], disk_axis[1],
                                        # test_disk_pos, test_disk_inc))
        # plt.plot(disk_axis[0][:2],
                 # disk_axis[1][:2],
                 # c='r',
                 # label='disk coord. axes')
        # plt.plot(disk_axis[0][2:], disk_axis[1][2:], c='r')
        # plt.plot(sky_axis[0][:2],
                 # sky_axis[1][:2],
                 # c='g',
                 # label='sky coord. axes')
        # plt.plot(sky_axis[0][2:], sky_axis[1][2:], c='g')

def Generate_radii_and_thetas_of_2D_data(data_2D, pa, inc, **kwarg):
    """Generate radius and polar angle profile of input 2D data array
    Input:
        data_2D : 2D array
        pa      : Position angle (in deg)
        inc     : Inclination angle (in deg)
        xc, yc  : Center of data (in pixel)
    Output:
        rs_pix: 2D array with corresponding radius (in pixel)
        theta : 2D array with corresponding theta angle (in deg)

    Args:
      data_2D: param pa:
      inc: param **kwarg:
      pa:
      **kwarg:

    Returns:

    """
    # Initialization
    empty = np.empty_like(data_2D)
    # Center of input data (in pixel)
    if ('cx' in kwarg) and ('cy' in kwarg):
        cx, cy = kwarg['cx'], kwarg['cy']
    else:
        cx, cy = int(len(empty[0])/2), int(len(empty)/2)

    # Generate radius, polar angle
    x_pix = np.array([np.arange(0, len(empty[0]), 1).astype(int) - cx])
    y_pix = np.array([np.arange(0, len(empty), 1).astype(int) - cy])

    # Radius after project from circular to ellptical ring
    x_pixs, y_pixs   = np.meshgrid(x_pix, y_pix)
    xp_pixs, yp_pixs = Project_to_sky_plane(x_pixs, y_pixs, pa, inc)
    rp_pixs = (xp_pixs ** 2 + yp_pixs ** 2) ** 0.5

    # Note: For normal arctan, it should be y/x, but here I want
    thetas  = np.rad2deg(np.arctan2(xp_pixs, yp_pixs))
    return rp_pixs, thetas

def Generate_azimuthal_cut(data_2D, rc_cut_pix, rw_cut_pix, pa, inc, **kwarg):
    """Generate azimuthal cut of 2D data array
    Input:
        data_2D : 2D array
        pa      : Position angle (in deg)
        inc     : Inclination angle (in deg)
        xc, yc  : Center of data (in pixel)
    Output:
        theta_list : 1D list with corresponding theta angle (in deg)
        cut_list   : 1D list with corresponding cut value

    Args:
      data_2D: param rc_cut_pix:
      rw_cut_pix: param pa:
      inc: param **kwarg:
      rc_cut_pix:
      pa:
      **kwarg:

    Returns:

    """
    # Initialization
    empty = np.empty_like(data_2D)
    # Center of input data (in pixel)
    if ('cx' in kwarg) and ('cy' in kwarg):
        cx, cy = kwarg['cx'], kwarg['cy']
    else:
        cx, cy = int(len(empty[0])/2), int(len(empty)/2)
    # Generate rs, thetas
    rp_pixs, thetas = Generate_radii_and_thetas_of_2D_data(data_2D, pa, inc,
                                                           cx=cx, cy=cy)
    # Azimuthal cut
    theta_list, cut_list = [], []
    x_rcw, y_rcw = np.where(abs(rp_pixs - rc_cut_pix) <= rw_cut_pix/2.)
    for x, y in zip(x_rcw.T, y_rcw.T):
        theta_list.append(thetas[y, x])
        cut_list.append(data_2D[y, x])
    return theta_list, cut_list

def Generate_non_average_PV_cut(data_3D, velax, rc, rw, pa, inc, interpolation=False, **kwarg):
    """Generate non average PV_cut (Exact data pixel by pixel + Interpolation)
    Input:
        data_3D : 3D PPV data cube
        velax   : Velocity on velocity axis (frequency axis)
        rc      : center of radius of ring (in pixel)
        rw      : width of ring (in pixel)
        pa      : position angle (in deg)
        inc     : inclination angle (in deg)
    Output:
        X : 2D array of theta
        Y : 2D array of velocity
        Z : 2D array of intensity

    Args:
      data_3D: param velax:
      rc: param rw:
      pa: param inc:
      interpolation: Default value = False)
      velax:
      rw:
      inc:
      **kwarg:

    Returns:

    """
    # Generate polar angle and velocity position coordinate in specific radius and width
    rp_pixs, thetas = Generate_radii_and_thetas_of_2D_data(data_3D[0], pa, inc, **kwarg)
    x_rcw, y_rcw = np.where(abs(rp_pixs - rc) <= rw/2.)

    # Get points from input data
    theta_list = []
    intensity_list = []
    velocity_list  = []
    for i, velocity in enumerate(velax):
        for x, y in zip(x_rcw.T, y_rcw.T):
            theta_list.append(thetas[y, x])
            intensity_list.append(data_3D[i][y, x])
            velocity_list.append(velocity)
    x = np.array(theta_list)
    y = np.array(velocity_list)
    z = np.array(intensity_list)

    if interpolation:
        # Start inteprolation from 3D sparse to 3D continuum
        ny, nx = len(velax), 720
        xmin, xmax = min(theta_list), max(theta_list)
        ymin, ymax = min(velocity_list), max(velocity_list)
        xi   = np.linspace(xmin, xmax, nx)
        yi   = np.linspace(ymin, ymax, ny)
        X, Y = np.meshgrid(xi, yi)
        Z    = griddata((x, y), z, (X, Y), method='nearest')
        return X, Y, Z
    else:
        # Reshape and Sort
        xr = x.reshape(len(velax), int(len(x)/len(velax)))
        yr = y.reshape(len(velax), int(len(y)/len(velax)))
        zr = z.reshape(len(velax), int(len(z)/len(velax)))
        xrs, yrs, zrs = [], [], []
        sort_ind = np.argsort(xr[0])
        for x, y, z in zip(xr, yr, zr):
            xs, ys, zs = x[sort_ind], y[sort_ind], z[sort_ind]
            xrs.append(xs)
            yrs.append(ys)
            zrs.append(zs)
        xrs, yrs, zrs = np.array(xrs), np.array(yrs), np.array(zrs)
        return xrs, yrs, zrs

def Get_peak_intensity_velocity(X, Y, Z):
    """Input:
        X : 2D array of theta
        Y : 2D array of velocity
        Z : 2D array of intensity
    Output:
        peak_list (velocity along polar angle (theta))

    Args:
      X: param Y:
      Z:
      Y:

    Returns:

    """
    # Plot peak
    peak_list = []
    for i in range(len(Z[0])):
        peak = Y[list(Z[:, i]).index(max(Z[:, i])), i]
        peak_list.append(peak)
    return peak_list
    # def derive_polar_angle_from_cartesian_test(self):
        # """Test derive_polar_angle_from_cartesian"""

        # test_disk_pos = 120.
        # test_x = np.linspace(-25, 25, 51)
        # test_y = np.linspace(-25, 25, 51)
        # grid_x, grid_y = np.meshgrid(test_x, test_y)
        # polar_angle_wo_disk_pos = self.derive_polar_angle_from_cartesian(
            # grid_x, grid_y)
        # polar_angle_wi_disk_pos = polar_angle_wo_disk_pos + test_disk_pos
        # plt.imshow(polar_angle_wi_disk_pos)
        # plt.title(
            # 'Polar angle derived from cartesian coord. (disk_pos={:.1f}Â°)'.
            # format(test_disk_pos))
        # plt.axis('equal')
        # cbar = plt.colorbar()
        # cbar.ax.set_ylabel('degree', rotation=270)
        # plt.show()

    # def generate_ring_boundary_on_sky(self, ring_center, ring_width,
                                            # disk_pos, disk_inc):
        # """Transform disk ring from disk polar coodinate to sky cartesian coordinate

        # Args:
          # ring_center(float): radius of center of ring boundary
          # ring_width(float): width of ring boundary
          # disk_pos(float): position angle of disk (unit: degree)
          # disk_inc(float): inclination angle of disk (unit: degree)

        # Returns:
          # 2D float array: boundary inner boundary x,y position on sky plane
          # 2D float array: boundary outer boundary x,y position on sky plane

        # """
        # # Set radius of inner/outer boundary of ring boundary
        # ring_inner_bound = ring_center - ring_width / 2.
        # ring_outer_bound = ring_center + ring_width / 2.

        # # Calculate ring inner/outer position in sky plane
        # ring_inner = self.transform_disk_polar_to_sky_cartesian(
            # ring_inner_bound,
            # disk_pos,
            # disk_inc,
        # )
        # ring_outer = self.transform_disk_polar_to_sky_cartesian(
            # ring_outer_bound,
            # disk_pos,
            # disk_inc,
        # )

        # return ring_inner, ring_outer

    # def generate_ring_boundary_on_sky_test(self):
        # """Test generate_ring_boundary_on_sky"""

        # # Test ring
        # max_width = 50.
        # test_disk_inc = 47.5
        # test_disk_pos = 120.
        # test_radius = 30.
        # test_central_radius = 30.
        # test_width = 5.

        # # Axis for both disk coord and sky coord
        # disk_axis = np.array([[max_width, -max_width, 0., 0.],
                              # [0., 0., max_width, -max_width]])
        # sky_axis = np.array(
            # CoordinateTransformation.transform_to_sky_coord(
                # disk_axis[0], disk_axis[1], test_disk_pos, test_disk_inc))
        # plt.plot(disk_axis[0][:2],
                 # disk_axis[1][:2],
                 # c='r',
                 # label='disk coord. axes')
        # plt.plot(disk_axis[0][2:], disk_axis[1][2:], c='r')
        # plt.plot(sky_axis[0][:2],
                 # sky_axis[1][:2],
                 # c='g',
                 # label='sky coord. axes')
        # plt.plot(sky_axis[0][2:], sky_axis[1][2:], c='g')

        # # Test origin of polar angle for coordinate transformation
        # test_dot_disk_x, test_dot_disk_y = test_radius, 0
        # test_dot_sky_x, test_dot_sky_y = CoordinateTransformation.transform_to_sky_coord(
            # test_dot_disk_x, test_dot_disk_y, test_disk_pos, test_disk_inc)
        # plt.scatter(test_dot_disk_x,
                    # test_dot_disk_y,
                    # label='disk coord. polar angle origin',
                    # color='r',
                    # alpha=1)
        # plt.scatter(test_dot_sky_x,
                    # test_dot_sky_y,
                    # label='sky coord. polar angle origin',
                    # color='g',
                    # alpha=1)

        # # Plot test ring boundary inner/outer bound
        # ring_inner, ring_outer = self.generate_ring_boundary_on_sky(
            # test_central_radius, test_width, test_disk_pos, test_disk_inc)
        # plt.scatter(ring_inner[0], ring_inner[1], label='ring inner boundary')
        # plt.scatter(ring_outer[0], ring_outer[1], label='ring_outer_boundary')

        # # Option for plot
        # plt.title(
            # 'Ring boundary on sky coord. (disk_inc={:.1f}Â°, disk_pos={:.1f}Â°)'.
            # format(test_disk_inc, test_disk_pos))
        # plt.axis('equal')
        # plt.legend()
        # plt.show()
    # @staticmethod
    # def transform_disk_polar_to_sky_cartesian(radius,
                                              # disk_pos,
                                              # disk_inc,
                                              # theta_slices=360):
        # """Transform disk ring from disk polar coodinate to sky coordinate cartesian

        # Args:
          # radius(float): radius of disk ring
          # disk_pos(float): position angle of disk (unit: degree)
          # disk_inc(float): inclination angle of disk (unit: degree)
          # theta_slices(int, optional): slices of a ring in theta direction (Default value = 360)

        # Returns:
          # 1D float array: x position on sky plane
          # 1D float array: y position on sky plane

        # """
        # # Theta list
        # theta_list = np.linspace(0., 360., theta_slices)

        # # Transform to sky coordinate
        # sky_x_list, sky_y_list = [], []
        # for theta in theta_list:
            # disk_x, disk_y = radius * np.cos(
                # np.deg2rad(theta)), radius * np.sin(np.deg2rad(theta))
            # sky_x, sky_y = CoordinateTransformation.transform_to_sky_coord(
                # disk_x, disk_y, disk_pos, disk_inc)
            # sky_x_list.append(sky_x)
            # sky_y_list.append(sky_y)

        # # List to array
        # sky_x_array = np.array(sky_x_list)
        # sky_y_array = np.array(sky_y_list)

        # return sky_x_array, sky_y_array

    # @staticmethod
    # def transform_sky_cartesian_to_sky_polar(x, y):
        # """

        # Args:
          # x(array): x position in cartesian coordinate
          # y(array): y position in cartesian coordinate

        # Returns:
          # array: radius in sky polar coordinate
          # array: polar angle in sky coordinate
        # """

        # radius = (x**2 + y**2) ** 0.5
        # polar_angle = np.rad2deg(np.arctan2(y, x))
        # return radius, polar_angle

    # @staticmethod
    # def convert_physical_length_to_pixel(physical_length, length_pixel_ratio):
        # """Convert physical_length to pixel number

        # Args:
          # physical_length(float): length in physical unit
          # length_pixel_ratio(float): lenght in physical unit per pixel

        # Returns:
          # int: pixel number

        # """
        # pixel_float = np.array(physical_length) * length_pixel_ratio
        # pixel_rint = np.rint(pixel_float)
        # pixel_int = pixel_rint.astype(int)
        # return pixel_int



    # def generate_data_polar(data, disk_pa, disk_inc):


        # empty = np.empty_like(data)


    # # if ('cx' in kwarg) and ('cy' in kwarg):
        # # cx, cy = kwarg['cx'], kwarg['cy']
    # # else:
    # # cx, cy = int(len(empty[0])/2), int(len(empty)/2)
